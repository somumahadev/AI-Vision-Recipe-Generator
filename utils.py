"""
Utility functions for AI Vision Recipe Generator
"""

import torch
from PIL import Image
import io
from typing import Dict, List, Tuple, Optional
import streamlit as st


def validate_image(image: Image.Image) -> Tuple[bool, str]:
    """
    Validate uploaded image for size and format
    
    Args:
        image: PIL Image object
        
    Returns:
        Tuple of (is_valid, error_message)
    """
    try:
        # Check minimum dimensions
        if image.size[0] < 50 or image.size[1] < 50:
            return False, "Image is too small. Please upload a larger image (at least 50x50 pixels)."
        
        # Check maximum dimensions
        if image.size[0] > 4096 or image.size[1] > 4096:
            return False, "Image is too large. Please upload an image smaller than 4096x4096 pixels."
        
        # Check file size (approximate)
        img_byte_arr = io.BytesIO()
        image.save(img_byte_arr, format='PNG')
        size_mb = len(img_byte_arr.getvalue()) / (1024 * 1024)
        
        if size_mb > 10:
            return False, "Image file is too large. Please upload an image smaller than 10MB."
        
        return True, ""
        
    except Exception as e:
        return False, f"Error validating image: {str(e)}"


def get_device_info() -> Dict[str, str]:
    """
    Get system device information
    
    Returns:
        Dictionary with device information
    """
    device = "cuda" if torch.cuda.is_available() else "cpu"
    
    info = {
        "device": device.upper(),
        "cuda_available": str(torch.cuda.is_available()),
    }
    
    if torch.cuda.is_available():
        info["gpu_name"] = torch.cuda.get_device_name(0)
        info["gpu_memory"] = f"{torch.cuda.get_device_properties(0).total_memory / 1e9:.2f} GB"
    
    return info


def format_recipe_text(
    dish: str,
    caption: str,
    recipe: str,
    nutrition: Dict[str, str],
    servings: int,
    difficulty: str,
    dietary_pref: str
) -> str:
    """
    Format recipe as text for export
    
    Args:
        dish: Name of the dish
        caption: Image description
        recipe: Generated recipe text
        nutrition: Nutritional information dict
        servings: Number of servings
        difficulty: Recipe difficulty level
        dietary_pref: Dietary preference
        
    Returns:
        Formatted recipe text
    """
    recipe_text = f"""
{'=' * 60}
{dish.upper()}
{'=' * 60}

SERVINGS: {servings}
DIFFICULTY: {difficulty}
{f"DIETARY: {dietary_pref}" if dietary_pref != "None" else ""}

IMAGE DESCRIPTION:
{caption}

NUTRITIONAL INFORMATION (per serving):
‚Ä¢ Calories: {nutrition['calories']}
‚Ä¢ Protein: {nutrition['protein']}
‚Ä¢ Carbohydrates: {nutrition['carbs']}
‚Ä¢ Fat: {nutrition['fat']}

{'=' * 60}
RECIPE
{'=' * 60}

{recipe}

{'=' * 60}
Generated by AI Vision Recipe Generator
Visit: https://github.com/yourusername/ai-vision-recipe-generator
{'=' * 60}
"""
    return recipe_text


def estimate_nutrition(dish: str) -> Dict[str, str]:
    """
    Estimate nutritional information based on dish name
    
    Note: This is a simplified estimation. For production,
    integrate with APIs like Edamam or Nutritionix.
    
    Args:
        dish: Name of the dish
        
    Returns:
        Dictionary with nutrition estimates
    """
    # Comprehensive nutrition database
    nutrition_db = {
        # Italian
        "pizza": {"calories": "285", "protein": "12g", "carbs": "36g", "fat": "10g"},
        "pasta": {"calories": "350", "protein": "13g", "carbs": "60g", "fat": "7g"},
        "lasagna": {"calories": "380", "protein": "18g", "carbs": "35g", "fat": "16g"},
        "risotto": {"calories": "320", "protein": "8g", "carbs": "55g", "fat": "9g"},
        
        # American
        "burger": {"calories": "540", "protein": "25g", "carbs": "40g", "fat": "27g"},
        "hot dog": {"calories": "290", "protein": "11g", "carbs": "24g", "fat": "17g"},
        "fries": {"calories": "365", "protein": "4g", "carbs": "48g", "fat": "17g"},
        
        # Asian
        "sushi": {"calories": "200", "protein": "9g", "carbs": "30g", "fat": "6g"},
        "ramen": {"calories": "450", "protein": "18g", "carbs": "60g", "fat": "15g"},
        "fried rice": {"calories": "370", "protein": "12g", "carbs": "55g", "fat": "11g"},
        "pad thai": {"calories": "400", "protein": "15g", "carbs": "50g", "fat": "14g"},
        "curry": {"calories": "320", "protein": "16g", "carbs": "35g", "fat": "12g"},
        "biryani": {"calories": "380", "protein": "20g", "carbs": "48g", "fat": "12g"},
        "dosa": {"calories": "220", "protein": "6g", "carbs": "38g", "fat": "5g"},
        "samosa": {"calories": "260", "protein": "5g", "carbs": "30g", "fat": "13g"},
        
        # Mexican
        "taco": {"calories": "210", "protein": "13g", "carbs": "20g", "fat": "9g"},
        "burrito": {"calories": "470", "protein": "21g", "carbs": "55g", "fat": "17g"},
        "quesadilla": {"calories": "380", "protein": "17g", "carbs": "35g", "fat": "18g"},
        
        # Breakfast
        "pancakes": {"calories": "220", "protein": "6g", "carbs": "38g", "fat": "5g"},
        "waffles": {"calories": "240", "protein": "7g", "carbs": "40g", "fat": "6g"},
        "omelette": {"calories": "180", "protein": "14g", "carbs": "3g", "fat": "12g"},
        "cereal": {"calories": "150", "protein": "3g", "carbs": "32g", "fat": "2g"},
        
        # Healthy
        "salad": {"calories": "150", "protein": "5g", "carbs": "15g", "fat": "8g"},
        "soup": {"calories": "120", "protein": "6g", "carbs": "18g", "fat": "3g"},
        "smoothie": {"calories": "180", "protein": "6g", "carbs": "35g", "fat": "2g"},
        
        # Desserts
        "cake": {"calories": "350", "protein": "4g", "carbs": "50g", "fat": "16g"},
        "ice cream": {"calories": "270", "protein": "5g", "carbs": "35g", "fat": "13g"},
        "cookie": {"calories": "140", "protein": "2g", "carbs": "20g", "fat": "6g"},
        "brownie": {"calories": "240", "protein": "3g", "carbs": "32g", "fat": "12g"},
    }
    
    # Try to match dish with database (case-insensitive, partial match)
    dish_lower = dish.lower()
    for key in nutrition_db:
        if key in dish_lower or dish_lower in key:
            return nutrition_db[key]
    
    # Default values if no match found
    return {
        "calories": "~300",
        "protein": "~15g",
        "carbs": "~40g",
        "fat": "~12g"
    }


def create_confidence_bar(confidence: float, height: int = 10) -> str:
    """
    Create HTML for confidence bar visualization
    
    Args:
        confidence: Confidence score (0-1)
        height: Height of bar in pixels
        
    Returns:
        HTML string for confidence bar
    """
    confidence_pct = confidence * 100
    
    html = f"""
    <div style="
        background-color: #2E2E2E;
        border-radius: 5px;
        height: {height}px;
        overflow: hidden;
        margin-top: 0.5rem;
    ">
        <div style="
            background: linear-gradient(90deg, #FF6B6B 0%, #FFE66D 100%);
            height: 100%;
            width: {confidence_pct}%;
            transition: width 0.3s ease;
        "></div>
    </div>
    """
    
    return html


def parse_recipe_sections(recipe: str) -> Dict[str, str]:
    """
    Parse recipe text into structured sections
    
    Args:
        recipe: Raw recipe text
        
    Returns:
        Dictionary with parsed sections
    """
    sections = {
        "ingredients": "",
        "instructions": "",
        "time": "",
        "tips": ""
    }
    
    # Simple parsing logic (can be enhanced)
    lines = recipe.split('\n')
    current_section = None
    
    for line in lines:
        line_lower = line.lower()
        
        if 'ingredient' in line_lower:
            current_section = 'ingredients'
        elif 'instruction' in line_lower or 'step' in line_lower:
            current_section = 'instructions'
        elif 'time' in line_lower:
            current_section = 'time'
        elif 'tip' in line_lower or 'note' in line_lower:
            current_section = 'tips'
        elif current_section:
            sections[current_section] += line + '\n'
    
    return sections


def calculate_scaled_servings(
    original_servings: int,
    target_servings: int,
    recipe: str
) -> str:
    """
    Scale recipe quantities based on serving size
    
    Note: This is a placeholder. Full implementation would
    require NLP parsing of ingredient quantities.
    
    Args:
        original_servings: Original number of servings
        target_servings: Target number of servings
        recipe: Recipe text
        
    Returns:
        Scaled recipe text
    """
    scale_factor = target_servings / original_servings
    
    # Add scaling note to recipe
    scaled_note = f"\n\nüìù Note: Recipe scaled for {target_servings} servings (scale factor: {scale_factor:.2f}x)\n"
    
    return recipe + scaled_note


@st.cache_data
def get_sample_images() -> List[str]:
    """
    Get list of sample image URLs for testing
    
    Returns:
        List of image URLs
    """
    return [
        "https://images.unsplash.com/photo-1565299624946-b28f40a0ae38",  # Pizza
        "https://images.unsplash.com/photo-1546069901-ba9599a7e63c",  # Salad
        "https://images.unsplash.com/photo-1555939594-58d7cb561ad1",  # Burger
        "https://images.unsplash.com/photo-1579584425555-c3ce17fd4351",  # Sushi
    ]


def log_error(error: Exception, context: str = "") -> None:
    """
    Log error with context
    
    Args:
        error: Exception object
        context: Additional context information
    """
    error_msg = f"Error in {context}: {type(error).__name__} - {str(error)}"
    st.error(f"‚ùå {error_msg}")
    
    # In production, send to logging service
    # logger.error(error_msg, exc_info=True)
